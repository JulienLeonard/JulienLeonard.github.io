function drawcircle(gl,circlex,circley,circler)
{
    // console.log("drawcircle",circle,color);
    // var gl = canvas;

    var i0 = gl.coordindex;
    gl.coords[i0 + 0] = circlex - 2.0 * circler;
    gl.coords[i0 + 1] = circley - circler;
    gl.coords[i0 + 2] = circlex;
    gl.coords[i0 + 3] = circley;
    gl.coords[i0 + 4] = circler;
    // gl.coords[i0 + 5] = color.r;
    // gl.coords[i0 + 6] = color.g;
    // gl.coords[i0 + 7] = color.b;
    // gl.coords[i0 + 8] = color.a;

    i0 += 5;

    gl.coords[i0 + 0] = circlex + 2.0 * circler;
    gl.coords[i0 + 1] = circley - circler;
    gl.coords[i0 + 2] = circlex;
    gl.coords[i0 + 3] = circley;
    gl.coords[i0 + 4] = circler;
    // gl.coords[i0 + 5] = color.r;
    // gl.coords[i0 + 6] = color.g;
    // gl.coords[i0 + 7] = color.b;
    // gl.coords[i0 + 8] = color.a;
    
    i0 += 5;

    gl.coords[i0 + 0] = circlex;
    gl.coords[i0 + 1] = circley + 2.0 * circler;
    gl.coords[i0 + 2] = circlex;
    gl.coords[i0 + 3] = circley;
    gl.coords[i0 + 4] = circler;
    // gl.coords[i0 + 5] = color.r;
    // gl.coords[i0 + 6] = color.g;
    // gl.coords[i0 + 7] = color.b;
    // gl.coords[i0 + 8] = color.a;

    i0 += 5;
    gl.coordindex = i0;
    
    // gl.coords.push(circle.x - 2.0 * circle.r, circle.y - circle.r,       circle.x, circle.y, circle.r, color.r, color.g, color.b, color.a);
    // gl.coords.push(circle.x,                  circle.y + 2.0 * circle.r, circle.x, circle.y, circle.r, color.r, color.g, color.b, color.a);
    // gl.coords.push(circle.x + 2.0 * circle.r, circle.y - circle.r,       circle.x, circle.y, circle.r, color.r, color.g, color.b, color.a);

    gl.nnewcircles += 1;
}

//
// viewbox is squared
// matrix to change from viewbox to (-1,-1,1,1)
//
function computeViewPortMatrix(gl,viewbox)
{
    var xmin = viewbox[0],
	ymin = viewbox[1],
	xmax = viewbox[2],
	ymax = viewbox[3];
    var xcenter = (xmin + xmax)/2.0;
    var ycenter = (ymin + ymax)/2.0;
    
    var xwidth = xmax - xmin;
    var ywidth = ymax - ymin;

    var canvasratio = gl.canvasratio; // w/h

    // console.log("computeViewPortMatrix canvasratio",canvasratio);
    
    var scalex = 2.0/xwidth;
    var scaley = 2.0/ywidth;
    var tx = -xcenter *scalex;
    if (canvasratio < 1.0) {
	tx = tx + (xwidth/2.0) * scalex * (canvasratio - 1.0);
    }
    var ty = -ycenter * scaley;
    if (canvasratio > 1.0) {
	ty = ty + (ywidth/2.0) * scaley * (1.0 - 1.0/canvasratio);
    }

    if (scalex != scaley) {
	console.log("ERROR: scale x",scalex,"!= scaley",scaley);
    }

    var scale = scalex
    
    return new Float32Array([scale, 0, 0, 0,
			     0, scale, 0, 0,
			     0, 0, 1, 0,
			     tx, ty, 0, 1]);

}

//
// viewbox is squared
// matrix to change from viewbox to (0,0,canvas.width,canvas.height)
//
function computeScreenPortMatrix(gl,viewbox)
{
    var xmin = viewbox[0],
	ymin = viewbox[1],
	xmax = viewbox[2],
	ymax = viewbox[3];
    var xcenter = (xmin + xmax)/2.0;
    var ycenter = (ymin + ymax)/2.0;
    
    var xwidth = xmax - xmin;
    var ywidth = ymax - ymin;

    var canvasratio = gl.canvasratio; // w/h

    var scalex = gl.canvaswidth/xwidth;
    var scaley = gl.canvasheight/ywidth;
    var tx = gl.canvaswidth/2  - xcenter *scalex;
    if (canvasratio < 1.0) {
	tx = tx + (xwidth/2.0) * scalex * (canvasratio - 1.0);
    }    
    var ty = gl.canvasheight/2  - ycenter * scaley;
    if (canvasratio > 1.0) {
	ty = ty + (ywidth/2.0) * scaley * (1.0 - 1.0/canvasratio);
    }

    // console.log("viewbox",viewbox);
    // console.log("canvas dims",gl.canvaswidth,gl.canvasheight);

    // console.log("Matrix scalex",scalex,"scaley",scaley,"tx",tx,"ty",ty);
    
    return new Float32Array([scalex, 0, 0, 0,
			     0, scaley, 0, 0,
			     0, 0, 1, 0,
			     tx, ty, 0, 1]);

}



function initcanvas(canvasname)
{

    // var w = 2000,
	// h = 2000,
	// background = Color.white();
    

    
    // Get A WebGL context
    var div = document.getElementById(canvasname);
    div.innerHTML = "<canvas id = \"" + "canvas" + canvasname  + "\"  />";
    canvas = document.getElementById("canvas" + canvasname);

    
    gl = getWebGLContext(canvas);
    if (!gl) {
	return;
    }

    var fragmentshaderscript = [
    	"#ifdef GL_OES_standard_derivatives",
        "#extension GL_OES_standard_derivatives : enable",
        "#endif",
    	"precision mediump float;",
	"varying vec2  vCircleCenter;",
	"varying float vCircleRadius;",
	"varying float vAlpha;",
    	"void main(void) {",
    	"vec2 cxy = vec2(gl_FragCoord) + vec2(0.5,0.5) - vCircleCenter;",
	"float alpha = 1.0;",
    	"float r =  (dot(cxy, cxy))/(vCircleRadius * vCircleRadius);",
    	"#ifdef GL_OES_standard_derivatives",
    	" float delta = fwidth(r);",
    	" alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);",
    	"#endif",
    	"   gl_FragColor = vec4(1.0,1.0,1.0,1.0) * alpha * vAlpha;",
    	"}"
    ];

    
    var vertexshaderscript = [
	"attribute vec2  aVertexPosition;",
	"attribute vec3  aCircleDef;",
	"uniform   mat4  uModelViewMatrix;",
	"uniform   mat4  uScreenViewMatrix;",
	"uniform   float uAlpha;",
	"varying   vec2  vCircleCenter;",
	"varying   float vCircleRadius;",
	"varying   float vAlpha;",
	"void main(void) {",
	"   gl_Position  = uModelViewMatrix * vec4(aVertexPosition, 0.0, 1.0);",
	"   vCircleCenter   = vec2(uScreenViewMatrix * vec4(aCircleDef[0], aCircleDef[1], 0.0,1.0));",
	"   vCircleRadius   = uScreenViewMatrix[0][0] * aCircleDef[2];",
	"   vAlpha          = uAlpha;",
	"}"
    ];

    // "   vCircleRadius   = (uScreenViewMatrix * vec4(aCircleDef[2], 0.0, 0.0,1.0))[0];",

    // "   gl_PointSize = (uModelViewMatrix * vec4(aVertexSize,0.0,0.0,0.0))[0];",

    // setup GLSL program
    vertexShader   = loadShader(gl, vertexshaderscript.join("\n"),   gl.VERTEX_SHADER);
    fragmentShader = loadShader(gl, fragmentshaderscript.join("\n"), gl.FRAGMENT_SHADER);

    program = createProgram(gl, [vertexShader, fragmentShader]);
    gl.useProgram(program);	

    // gl.mybackground = background.v4();

    gl.modelviewmatrixloc  = gl.getUniformLocation(program, 'uModelViewMatrix');
    gl.alpha               = gl.getUniformLocation(program, 'uAlpha');
    gl.screenviewmatrixloc = gl.getUniformLocation(program, 'uScreenViewMatrix');
    gl.vertexposloc        = gl.getAttribLocation(program,  'aVertexPosition');
    gl.circledef           = gl.getAttribLocation(program,  'aCircleDef');
    // gl.colorloc           = gl.getAttribLocation(program,  'aColor');

    gl.enableVertexAttribArray(gl.vertexposloc);
    gl.enableVertexAttribArray(gl.circledef);
    // gl.enableVertexAttribArray(gl.colorloc);

    // gl.cpoints = [];
    gl.batchs = [];
    // initfornextbatch(gl);

    gl.viewbox0 = [-1.0,-1.0,1.0,1.0];

    var onresize = function() {
    	// console.log("resize");
    	// canvas = document.getElementsByTagName('canvas')[0];
	var ww = window.innerWidth;
	var wh = window.innerHeight;
	var realToCSSPixels = window.devicePixelRatio;
	var maxdim = wh > ww ? wh : ww;
	var w =  maxdim;
	var h =  maxdim;

	canvas.width  = w;
	canvas.height = h;

	gl.canvaswidth  = w;
	gl.canvasheight = h;
	
        var canvasratio = ww / wh;
	console.log("canvas.innerWidth",ww,"canvas.innerHeight",wh);
	gl.canvasratio  = canvasratio;
	gl.viewport(0,0, gl.canvaswidth, gl.canvasheight);

	resetviewbox(gl);
    };

    window.onresize = onresize;
    onresize();
}

//
// return a map bcoords and bindices of glbuffer loaded
function createnewbatch(gl)
{
    // console.log("createnewbatch coords",coords.length,"indices",indices.length);
    var result = {};
    result.bcoords  = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, result.bcoords);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gl.coords), gl.STATIC_DRAW);

    result.ncircles = gl.nnewcircles;
    result.alpha = 1.0;
    result.alphaincr = 0.05;
    // result.maxalpha = 1.0 - 0.005 * gl.batchs.length;
    // result.ncircles = gl.coords.length/9;
    
    
    return result;
}

// here all the uniforms have alrady been set
function redrawbatch(gl,batch)
{
    // console.log("redrawbatch indices",batch.indiceslength);
    gl.bindBuffer(gl.ARRAY_BUFFER, batch.bcoords);

    gl.vertexAttribPointer(gl.vertexposloc,  2, gl.FLOAT, false, 4 * 5, 0     );
    gl.vertexAttribPointer(gl.circledef,     3, gl.FLOAT, false, 4 * 5, 2 * 4 );
    // gl.vertexAttribPointer(gl.colorloc,      4, gl.FLOAT, false, 4 * 9, 5 * 4 );

    gl.drawArrays(gl.TRIANGLES, 0, batch.ncircles * 3 );
    batch.alpha += batch.alphaincr;
    // if (batch.alpha > 1.0) {
    // 	batch.alphaincr = -0.02;
    // } else {
    // 	if (batch.alpha < 0.0) {
    // 	    batch.alphaincr = 0.01;
    // 	}
    // }
    // console.log("batch alppha",batch.alpha);
}


function resetviewbox(gl)
{
    // var cviewbox = gl.viewbox0;
    
    // redraw the webgl canvas
    // gl.clearColor(gl.mybackground[0],gl.mybackground[1],gl.mybackground[2],1.0);     
    // gl.clear(gl.COLOR_BUFFER_BIT);
    if (true) {
	gl.clearColor(0.0,0.0,0.0,1.0);     
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); // To disable the background color of the canvas element
	gl.enable(gl.BLEND);
	gl.disable(gl.DEPTH_TEST);
    }
    
    // set the viewport matrix
    var newmodelViewMatrix = computeViewPortMatrix(gl, gl.viewbox0);
    gl.uniformMatrix4fv(gl.modelviewmatrixloc, false, newmodelViewMatrix);

    var newScreenViewMatrix = computeScreenPortMatrix(gl,gl.viewbox0);
    gl.uniformMatrix4fv(gl.screenviewmatrixloc, false, newScreenViewMatrix);

    // then redraw all the buffers
    var ncircles = 0;
    for (var i = 0; i < gl.batchs.length; i++)
    {
	var batch = gl.batchs[i];
	var balpha = batch.alpha < 1.0 ? batch.alpha : 1.0; 
	gl.uniform1f(gl.alpha, balpha);
	redrawbatch(gl,batch);
	ncircles += batch.ncircles;
    }

    console.log("ncircles",ncircles);
    
    // // reset the data for the next batch
    // initfornextbatch(gl);
}

// function initfornextbatch(gl)
// {
//     gl.coords  = [];
// }

function startanim(fframe) {
    execloop(fframe);
}

function execloop(fframe) {
    fframe();
    requestAnimationFrame(execloop);
}

// function relaunchloop(conditionresult,flaunch) {
//     if (conditionresult) {
// 	requestAnimationFrame( flaunch );
//     }
// }

function bindcanvas(canvas,event,f,condition) {
    // canvas.on(event,f,condition);
    // TODO
}

function myhsla(h,s,l,a) {
    return (new Color()).hsla(h,s,l,a);
}
